# 📌C++ 中的堆和栈
在 C++ 中，**堆和栈**是两种常见的内存分配区域，它们分别用于不同类型的数据存储。理解它们的工作原理对编写高效、稳定的程序非常重要。
## 1. 栈（Stack）

### 定义
1. 栈是由操作系统自动管理的一块内存区域，用于存储局部变量、函数调用信息和返回地址。
2. 栈内存是后进先出（LIFO，Last In First Out）的结构。

### 特性
1. 自动管理：栈内存的分配和回收是由编译器自动进行的，无需显式管理。
2. 快速分配和回收：栈内存分配非常快速，栈帧（函数调用）的压入和弹出操作通常是常数时间 O(1)。
3. 生命周期有限：栈上的数据会随着函数的调用和返回而自动销毁，生命周期非常短。
4. 大小有限：栈内存大小是固定的，通常由操作系统决定。栈的大小通常比堆小，因此栈的空间容易耗尽（栈溢出）。

### 栈的存储：
1. 当你定义局部变量时，它们会被分配到栈上。
2. 当函数调用时，函数的返回地址、参数和局部变量会被压入栈中。
3. 函数执行完毕时，这些信息会被弹出栈。

### 栈溢出（Stack Overflow）:
栈溢出发生在栈空间耗尽时，通常由递归过深或局部变量占用过多空间引起。

## 2. 堆（Heap）
### 定义
1. 堆是用于动态分配内存的区域，程序员需要手动管理。
2. 它允许程序在运行时动态地分配和释放内存。

### 特性
1. 手动管理：堆内存需要程序员显式地分配和释放，使用 new 和 delete（C++）来管理堆内存。
2. 慢速分配和回收：堆内存的分配和释放比栈慢，因为需要进行内存的查找、管理和回收。
3. 生命周期灵活：堆内存可以在整个程序运行期间存活，直到手动释放。
4. 大小较大：堆的内存比栈要大得多，适合存储较大或不确定大小的数据。

### 堆的存储：
1. 当你使用 new 来分配内存时，内存分配在堆上。
2. 使用 delete 来手动释放堆内存。
3. 动态分配的内存不会在作用域结束时自动销毁，必须显式释放。


### 内存泄漏：
内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

当我们在程序中对原始指针(raw pointer)使用new操作符或者free函数的时候，实际上是在堆上为其分配内存，这个内存指的是RAM，而不是硬盘等永久存储。持续申请而不释放(或者少量释放)内存的应用程序，最终因内存耗尽导致OOM(out of memory)。

#### 内存泄漏分为以下两类：

1. 堆内存泄漏：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用。

2. 资源泄漏：通常指的是系统资源，比如socket，文件描述符等，因为这些在系统中都是有限制的，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用。

在Linux系统上，可用通过如下命令来查看栈大小：
```shell
ulimit -s
```
在Linux系统上，栈大小通常为通常为 8MB 到 10MB，堆大小通常为3个GB。